!function(t){function e(i){if(n[i])return n[i].exports;var s=n[i]={exports:{},id:i,loaded:!1};return t[i].call(s.exports,s,s.exports,e),s.loaded=!0,s.exports}var n={};return e.m=t,e.c=n,e.p="",e(0)}([function(t,e,n){var i=n(1),s=n(2),r=n(4),o=n(5),a=n(7),h=n(11),c=(n(8),n(9)),u=n(12),p=n(13),f=function(t,e){i.each(t,function(t,e){if(!i.isEqual(t,r[e].toJS())){var n=this.stores[e];n.emitChanging(),r[e]=g.toImmutable(t),n.emitChange()}},e)},l=s.extend({initialize:function(t){this._cleanUp(),t&&t.debug===!0?this.log=p:this.log=i.noop,this.on("before:destroy",this._cleanUp)},stores:{},actions:{},actionTypes:{},getters:{},evaluate:function(t){return t&&t.length>0?1===t.length?i.clone(r[t[0]]):i.map(t,function(t){return r[t]}):i.clone(r)},createStore:function(t){var e=a.extend(t);return e.prototype.actionTypes=this.actionTypes,new e},createAction:function(t,e){if(i.isFunction(e)){if(0===i.pluck(this.actions,t).length)return e.prototype.actionTypes=this.actionTypes,e.prototype.actions=i.omit(this.actions,t),e.prototype.dispatch=this.dispatch,this.actions[t]=e,this.actions[t];throw new Error(u("Action with the same id: {0} already exists",t))}throw Error(u("Second parameter must be a function. Received {0}",typeof e))},createActionType:function(t){var t=t.toUpperCase();if(0===i.pluck(this.actionTypes,t).length)return this.actionTypes[t]=t,this.actionTypes[t];throw new Error(u("Action type: {0} already exists",t))},createGetter:function(t,e,n){if(i.contains(i.keys(this.getters),t))throw Error(u("Getter with the same id: {0} already exists",t));return this.getters[t]=new h(t,e,n,this)},registerStores:function(t){var e=this;i.each(t,function(t,n){var i=e.stores[n]=t;i.Id=n,r[t.Id]=t._getInitalStateValue()})},dispatch:function(t){this.log("Dispatching action: {0} with payload of {1}",t.type,t.data),o.dispatch(t)},bootstrap:function(t){var e={};if(i.isString(t))e=JSON.parse(t);else{if(!i.isObject(t))throw new Error("Desired state data passed was not a supported type");e=t}f(t,this)},takeSnapshot:function(t){var e={};t&&i.isArray(t)&&t.length>0?i.each(t,function(t){e[t]=r[t].toJSON()}):i.each(r,function(t,n){e[n]=t.toJSON()}),sessionStorage.setItem("lastSnapshot",JSON.stringify({data:e}))},flush:function(){i.each(this.stores,function(t){var e=t._getInitalStateValue();r[t.Id]!==e&&(t.emitChanging(),r[t.Id]=e,t.emitChange())},this)},recycle:function(t){var e=function(t){var e=t._getInitalStateValue();i.isEqual(t.getState().toJS(),e.toJS())||(t.emitChanging(),r[t.Id]=e,t.emitChange())};if(t&&i.isArray(t)&&t.length>0){var n=this;i.each(t,function(t){e(n.stores[t])})}else i.each(this.stores,function(t,n){e(t)})},rollback:function(){var t=JSON.parse(sessionStorage.getItem("lastSnapshot")).data;if(!t)throw new Error("Rollback was called before a snapshot was taken");f(t,this)},_cleanUp:function(){this.stores.length>0&&i.each(this.stores,function(t,e){t.destroy()},this),this.getters.length>0&&i.each(this.getters,function(t,e){t.destroy()},this),this.stores={},this.getters={},r={}}}),g=i.extend(l,c);t.exports=g},function(t,e){t.exports=_},function(t,e,n){function i(t){this.options=r.extend({},r.result(this,"options"),t),this.initialize.apply(this,arguments)}var s=n(3),r=n(1);i.extend=s.Model.extend,r.extend(i.prototype,s.Events,{initialize:function(){},onBeforeDestroy:r.noop,onDestroy:r.noop,destroy:function(){return this.trigger("before:destroy"),this.onBeforeDestroy(),this.trigger("onDestroy"),this.onDestroy(),this.stopListening(),this}}),t.exports=i},function(t,e){t.exports=Backbone},function(t,e){var n={};t.exports=n},function(t,e,n){var i=n(6),s=new i.Dispatcher;t.exports=s},function(t,e){t.exports=Flux},function(t,e,n){var i=n(1),s=n(5),r=n(2),o=n(4),a=n(8),h=n(9),c=function(t,e){if(!e.isImmutable(t))throw new Error("Error in setting the state id = "+e.Id+". State must be of type immutable");e.emitChanging(),o[e.Id]=t,e.emitChange()},u=r.extend({constructor:function(){this._processDispatcherEventHash(),this.dispatchToken=s.register(i.bind(this._processEvent,this)),this.on("before:destroy",this._cleanUp),this.Id=i.uniqueId("fs"),r.prototype.constructor.apply(this,arguments)},getState:function(){return o[this.Id]},onSerialize:i.noop,onDeserialize:i.noop,getInitialState:i.noop,_cleanUp:function(){s.unregister(this.dispatchToken),this.stopListening()},_processEvent:function(t){if(this.dispatcherEvents&&this.dispatcherEvents[t.type]){var e=this.dispatcherEvents[t.type](this.getState(),t.data);if(i.isUndefined(e)||null===e)throw new Error("A dispatch event must return the new state. Even if your not changing the state just return it back");this.trigger("dispatchHandled"),this.getState()!=e&&c(e,this)}},_processDispatcherEventHash:function(t){t||(t=i.result(this,"dispatcherEvents"));for(var e in t){var n=t[e];i.isFunction(n)||(n=this[n]),this._convertStringCallback(e,i.bind(n,this))}},_convertStringCallback:function(t,e){this.dispatcherEvents[t]=e},_getInitalStateValue:function(){var t=this.getInitialState();return t?(this.isImmutable(t)||(t=this.toImmutable(t)),t):Immutable.Map({})},waitFor:function(t){if(!t)throw Error("Error in BaseStore.waitFor ids were undefined");var e;e=i.isArray(t)?t.map(function(t){return i.isString(t)?t:t.dispatchToken}):i.isString(t)?[t]:[t.dispatchToken],s.waitFor(e)}});i.extend(u.prototype,a,h),t.exports=u},function(t,e){var n={emitChange:function(){this.trigger("change"),this.trigger("state:changed")},emitChanging:function(){this.trigger("changing"),this.trigger("state:changing")}};t.exports=n},function(t,e,n){var i=n(10),s=n(1);t.exports={isImmutable:function(t){return i.Iterable.isIterable(t)},isImmutableValue:function(t){return isImmutable(t)||!s.isObject(t)},toJS:function(t){return isImmutable(t)?t.toJS():t},toImmutable:function(t){return isImmutable(t)?t:i.fromJS(t)}}},function(t,e){t.exports=Immutable},function(t,e,n){var i=n(1),s=n(2),r=n(8),o=n(9),a=n(12),h=s.extend({_deps:[],dependencies:[],sourceVals:[],computeFunc:i.noop,initialize:function(t,e,n,s){this.name=t,this.dependencies=e,this.computeFunc=n,this.fluxer=s,this._ghettoDI(e),i.each(this._deps,function(t){this.listenTo(t,"change",this._onDepChanged)},this),this.on("before:destroy",this._cleanUp)},getState:function(){return this._generateState(this.sourceVals)},_ghettoDI:function(t){this._deps=i.map(t,function(t){var e=t;if(i.isString(e)){if(this.fluxer.stores[t])e=this.fluxer.stores[t];else{if(!this.fluxer.getters[t])throw Error(a("Error in {1} converting string dependency could not find {0} in stores or getters for this flux instance",t,this.name));e=this.fluxer.getters[t]}return e}throw Error(a("Error in {0} dependencies must be strings",this.name))},this),this._updateSourceVals()},_onDepChanged:function(){this.emitChanging(),this._updateSourceVals()},_updateSourceVals:function(){var t=i.clone(this.sourceVals);this.sourceVals=i.map(this._deps,function(t){return t.getState()},this),t!=this.sourceVals&&this.emitChange()},_generateState:function(t){if(this._deps.length==t.length){var e=this.computeFunc.apply(this,t);if(e)return _logger("{0}: has new state value of {1}",this.name,e),e;throw Error(a("Error in {0} \n All getter functions must return a value",this.name))}_logger("{0}: not all deps have a source value",this.name)},_cleanUp:function(){this.stopListening()}});i.extend(h.prototype,r,o),t.exports=h},function(t,e){function n(t){var e=arguments,n=t.replace(/{(\d+)}/g,function(t,n){var i;if(++n,"undefined"!=typeof e[n]){var s=e[n];i=_.isString(s)?s:JSON.stringify(s)}else i=t;return i});return n}t.exports=n},function(t,e,n){var i=n(12),s=function(t){console.log(i(t))};t.exports=s}]);